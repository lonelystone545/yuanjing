1 数据量太大，邮件报警服务承受不了那么多。和运维沟通过了
2 可读性非常差。

从kafka中取数据，数据量太大，会占用较大的网络带宽，而且占用大量本地内存

1 根据不同的负责人进行分发邮件
2 邮件按照领域进行划分，如光 风
3 支持web前端的配置，如黑名单 设置任务执行周期 对不同的数据设置报警时间段（如光来说，晚上就不会监控） 

mqtt协议是一种基于发布、订阅模式的轻量级的通讯协议，该协议构建于TCP/IP协议上。（异步）
优点：是一种低开销 低带宽占用的即时通讯协议，适合在物联网 小型设备 移动应用中。（协议的头部只有2字节，减少网络流量，适合低带宽）
对传输消息有三种服务质量：最多一次 至少一次 只有一次，适应在不稳定工作的网络传输需求，让消息能够按需到达目的地。
通知机制：异常中断时，会通知传输双方，mqtt协议本身维护了心跳机制
mqtt协议旨在低带宽和不稳定的网络环境中的物联网设备提供可靠的网络服务。
非常小的通信开销：2字节消息头

标准			http	mq	mqtt
机密性			是	是	是
低协议开销		否	否	是
对不稳定网络容忍	否	是	是
低功耗			否	否	是
数百万连接的客户	否	否	是
推送通信		是	是	是
客户端平台差异		是	否	是
防火墙容错		是	否	是
http://bbs.elecfans.com/forum.php?mod=viewthread&tid=911474&extra=page=3&typeid=470

kafka是为了数据集成的场景，通过分布式架构提供了海量消息的处理 高容错方式存储海量数据，保证数据流的顺序等。
mqtt是为了物联网场景而优化，提供多个Qos选项，还有层级主题 遗嘱等特性。
如图所示，broker1-3是mqtt集群，nginx是作为负载均衡器，client通过nginx可以连接到集群中任意一个broker上。
mqtt协议本身是不支持集群部署的，只支持单机。也就是说，

Client ID:客户端到服务端的唯一标识符，所以必须全局唯一的

mqtt是应用层协议，基于tcp/ip。。tcp/ip是传输层协议。
mqtt协议本身维护了心跳机制，不需要我们

以广播的方式询问是否clientID是否已经连接到某个broker上，如果存在，则踢掉相同的clientID的旧连接


不借助其他的消息中间件或者http
http短连接，耗时太长，性能差
使用其他消息中间件带来额外的资源负担，及时性比不上broker之间的直接通讯

mqtt优点：长连接，性能好
	基于mqtt协议本身的连接状态维护，不需要自己再去基于netty开发、维护心跳等信息
	broker之间的消息传递，基于mqtt订阅发布模型，可实现类似异步通信方式

难点：
1 涉及到异步 多线程，编程复杂，还需要考虑性能
2 设计！需要想好如何去设计，包括topic的设计，topic内容的设计。

询问时是广播，回来是单播

访问多台机器时，需要并行处理
broker之间的远程调用控制在2ms以内
集群中只有一台或者两台机器时要优化处理流程

mqtt：当client订阅某个topic消息时，broker会找到订阅这个topic的所有clientid，然后进行分发。
client1在broker1上发布消息，client2和client3在其他broker上订阅这个topic的消息。这时client1需要找到订阅这个topic的所有clientid，然后
找到各个clientid所在broker，将消息发送给对应的broker，各个broker再给对应的client进行发送。
而topic对应的clientid这些信息会存储在redis缓存中。而且redis中会存储部分消息，如retained=1时，是要求对这个topic的最后一个消息进行持久化，
当断开的broker重新连接上来之后，会将这个topic的最后一条消息存储下来。


log常用的级别：info debug warn error
error：并不是出现异常的地方就打error。代表出现问题，可能是程序问题 环境问题，需要解决的才要打error。比如用户调用一个接口，
	传过来一个不在接口接受范围内的值，这不能打error，因为传什么值是用户决定的，不会影响程序运行。如果服务器上有监控程序，检测到error或者warn
	就报警，那么运维会疯掉。
warn：出现了不影响程序正确运行的问题。比如访问一个接口，设置了超时之后抛出异常，在try中不该打error或者info，应该打warn，警告一下，如果超时
	过多就该检查一下，是不是对方接口或者网络出现问题。
info和debug：一般的信息。帮助分析问题或者程序运行情况，应该打info。如果是为了在调试阶段查看程序是否运行正确就要打debug。



分布式：将一个大的任务拆分成多个子任务，部署在不同的节点上执行
集群：只要有多个节点就是集群，集群中的节点执行相同的任务
比如，web网站，前端负载均衡器，后面连接多个节点，这就是集群，当有业务时，就会把这个业务分发给其中一个节点处理。

stream 流式计算：对数据流进行计算，和实时计算不完全一样，实时计算侧重响应性，越快越好，离线计算通常用来计算耗时比较久的（数据库）。
而流式计算比实时计算稍微慢一点，但是比离线计算好。从消息队列来了数据后，就会进行实时处理。
flume是负责数据收集，可以用于拉取数据，然后持久化到数据库中。